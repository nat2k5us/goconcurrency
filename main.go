package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"runtime"
	"sync"
	"time"
)

func GetOrders(account string) {

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	req, err := http.NewRequest("GET", "http://127.0.0.1:8001/brokerage/accounts/"+account+"/orders", nil)
	if err != nil {
		// handle err
	}
	token := " Bearer xxx"
	req.Header.Set("Authorization", token)
	req.Header.Set("Cache-Control", "no-cache")
	req.Header.Set("Postman-Token", "7b0e630f-00f3-ca93-df46-5b3ccfb77c4a")
	req.Header.Set("X-Ts-Auth-User-Id", "omgxxxx")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		// handle err
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusOK {
		bodyBytes, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Fatal(err)
		}
		bodyString := string(bodyBytes)
		fmt.Println(bodyString)
	}
}

func GetOrdersParallel() {
	accounts := []string{"mkxxxxxx", "1929977951%20QA"}
	startAcc := time.Now()
	accountCount := 0
	for _, acct := range accounts {
		go func(acct string) {
			GetOrders(acct)
			accountCount++
		}(acct)
	}
	for accountCount < len(accounts) {
		time.Sleep(1 * time.Millisecond)
	}
	elaspedAcc := time.Since(startAcc)
	fmt.Println("Accounts time: ", elaspedAcc)
}

func SendValue(c chan string) {
	fmt.Println("executing go routine")
	c <- "Hello Channel" // see the ref kinda operation - value of channel var is set
	time.Sleep(1 * time.Second)
	fmt.Println("finished exuting go routine ..")
}

func TestParrallProc() {
	// <- is the channel operator
	// you make a channel using make (chan Type)
	c := make(chan string, 2) // Make a channel
	defer close(c)            // prevents interaction

	go SendValue(c)
	go SendValue(c)
	go SendValue(c)
	value := <-c
	fmt.Println(value)

	time.Sleep(2 * time.Second)
}

var wgGlobal sync.WaitGroup

func foo(c chan int, someValue int) {
	defer wgGlobal.Done() // keep channel open till done - might be decrementing wg index when done
	c <- someValue * 5
}

func WaitGroupTest() {
	fooVal := make(chan int, 10)
	for i := 0; i < 10; i++ {
		wgGlobal.Add(1)
		go foo(fooVal, i)
	}
	wgGlobal.Wait() // blocks till wait group no longer needs to wait
	close(fooVal)

	for item := range fooVal {
		fmt.Println(item)
	}
}

func WGTest2() {

	var wg sync.WaitGroup
	wg.Add(1) // increment index
	go func() {
		fmt.Println("")
		time.Sleep(time.Second)
		fmt.Println("delay")
		wg.Done() //release block
	}()
	fmt.Println("Waiting。。。")
	wg.Wait() //block
}

func asyncGo() {
	fmt.Println("This will happen first")

	go func() {
		fmt.Println("This will happen at some unknown time")
	}()

	fmt.Println("This will either happen second or third")

	fmt.Scanln()
	fmt.Println("done")
}

func asyncGo2() {
	a := 1
	b := 2

	go func() { // B2
		b = a * b
	}()

	a = b * b // B1

	fmt.Println("Hit Enter when you want to see the answer")
	fmt.Scanln()
	// prints a= 4 and b = 8 - as B1 executes before B2
	// this is what is called a race condition
	fmt.Printf("a = %d, b = %d\n", a, b)
}

func asyncUsingChannelsToAvoidRaceConditions() {
	a := 1
	b := 2

	operationDone := make(chan bool) // creating the channel
	go func() {                      // this is how you make the async call in go
		b = a * b

		operationDone <- true
	}()

	// this tells the main thread to wait for a message to be pushed into channel (i.e bool)
	<-operationDone

	a = b * b

	fmt.Println("Hit Enter when you want to see the answer")
	fmt.Scanln()

	fmt.Printf("a = %d, b = %d\n", a, b)
}

func WaitingOnAllRoutinesToFinish() {
	rand.Seed(time.Now().UTC().UnixNano())

	respond := make(chan string, 5)
	var wg sync.WaitGroup

	wg.Add(5)
	go checkDNS(respond, &wg, "pragmacoders.com", "ns1.nameserver.com")
	go checkDNS(respond, &wg, "pragmacoders.com", "ns2.nameserver.com")
	go checkDNS(respond, &wg, "pragmacoders.com", "ns3.nameserver.com")
	go checkDNS(respond, &wg, "pragmacoders.com", "ns4.nameserver.com")
	go checkDNS(respond, &wg, "pragmacoders.com", "ns5.nameserver.com")

	wg.Wait()
	close(respond)

	for queryResp := range respond {
		fmt.Printf("Got Response:\t %s\n", queryResp)
	}
}

func checkDNS(respond chan<- string, wg *sync.WaitGroup, query string, ns string) {
	defer wg.Done()

	time.Sleep(time.Duration(rand.Intn(10)) * time.Second)
	respond <- fmt.Sprintf("%s responded to query: %s", ns, query)
}

func AsyncSequentialCallToRoutines(wg sync.WaitGroup) {
	wg.Add(3)
	var firstUserData, secondUserData, thirdUserData string
	// First DB call
	go func() {

		firstUserData = firstDbCall()
		defer wg.Done()
	}()

	// Second DB call
	go func() {

		secondUserData = secondDbCall()
		defer wg.Done()
	}()

	// Third DB call
	go func() {

		thirdUserData = thirdDbCall()
		defer wg.Done()
	}()

	wg.Wait()

	println(firstUserData, secondUserData, thirdUserData)
}

// Group 1
func firstDbCall() string {

	time.Sleep(time.Duration(15 * time.Second))
	return "UserId1"
}

func secondDbCall() string {

	time.Sleep(time.Duration(10 * time.Second))
	return "UserId2"
}

func thirdDbCall() string {

	time.Sleep(time.Duration(5 * time.Second))
	return "UserId3"
}

func main() {

	runtime.GOMAXPROCS(2)
	//asyncGo()
	//asyncGo2()
	//asyncUsingChannelsToAvoidRaceConditions()
	//WaitingOnAllRoutinesToFinish()

	AsyncSequentialCallToRoutines(wgGlobal)

	//AsyncSequenciallyUsingChannelsAndSlices()
	// WaitGroupTest()
	//WGTest2()
	//TestParrallProc()
	//GetOrdersParallel()
	//GetQuotesParallel()
}

// Group 2
func firstDBCall(resultSlice *[]string, doneChannel chan bool) {
	(*resultSlice)[0] = "1"
	doneChannel <- true
}

func secondDBCall(resultSlice *[]string, doneChannel chan bool) {
	(*resultSlice)[1] = "2"
	doneChannel <- true
}

func thirdDBCall(resultSlice *[]string, doneChannel chan bool) {
	(*resultSlice)[2] = "3"
	doneChannel <- true
}

func AsyncSequenciallyUsingChannelsAndSlices() {
	resultSlice := make([]string, 3)
	doneChannel := make(chan bool)
	go firstDBCall(&resultSlice, doneChannel)
	go secondDBCall(&resultSlice, doneChannel)
	go thirdDBCall(&resultSlice, doneChannel)

	for i := 0; i < 3; i++ {
		<-doneChannel
	}
	fmt.Println(resultSlice)
}

func GetQuotesParallel() {
	numComplete := 0
	stockSymbols := []string{"AMZN", "AAPL", "DIS", "NVDA", "TSLA"}

	start := time.Now()
	for _, symbol := range stockSymbols {
		go func(symbol string) {
			url := "https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=" + symbol + "&apikey=" + "NVBWKBA9R7V7WQR9"

			//fmt.Println(url)
			//data := getDataFromUrl(url)
			getDataFromUrl(url)
			//fmt.Println(data)
			numComplete++
		}(symbol)
	}

	for numComplete < len(stockSymbols) {
		time.Sleep(1 * time.Millisecond)
	}
	elasped := time.Since(start)
	fmt.Println("execution time:", elasped)

}

func UnmarshalQuote(data []byte) (QuoteResponse, error) {
	var r QuoteResponse
	err := json.Unmarshal(data, &r)
	return r, err
}

func (r *QuoteResponse) Marshal() ([]byte, error) {
	return json.Marshal(r)
}

type QuoteResponse struct {
	The01Symbol           string `json:"01. symbol"`
	The02Open             string `json:"02. open"`
	The03High             string `json:"03. high"`
	The04Low              string `json:"04. low"`
	The05Price            string `json:"05. price"`
	The06Volume           string `json:"06. volume"`
	The07LatestTradingDay string `json:"07. latest trading day"`
	The08PreviousClose    string `json:"08. previous close"`
	The09Change           string `json:"09. change"`
	The10ChangePercent    string `json:"10. change percent"`
}

func getDataFromUrl(url string) string {

	var data string
	response, err := http.Get(url)
	if err != nil {
		fmt.Printf("The HTTP request failed with error %s\n", err)
	} else {
		data, _ := ioutil.ReadAll(response.Body)
		return string(data)
	}

	return string(data)
}
